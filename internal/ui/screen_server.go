package ui

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

// ServerScreenModel handles the server emulator screen.
type ServerScreenModel struct {
	state *AppState

	// Form fields
	ListenIP    string
	Port        string
	Personality int // Index into personalities slice
	ConfigPath  string

	// UI state
	focusIndex int
	Running    bool
	Completed  bool   // True after server stops (success or failure)
	Status     string
	Output     string // Captured stdout from the run
	RunDir     string // Directory where artifacts were saved

	// Stats when running
	StartTime       *time.Time
	Uptime          time.Duration
	ConnectionCount int
	RequestCount    int
	ErrorCount      int
	Connections     []ServerConnection
	RecentRequests  []ServerRequest
}

// ServerConnection represents an active connection.
type ServerConnection struct {
	RemoteAddr string
	SessionID  string
	IdleTime   time.Duration
}

// ServerRequest represents a recent request for display.
type ServerRequest struct {
	Time       time.Time
	RemoteAddr string
	Service    string
	Path       string
}

var serverPersonalities = []struct {
	Name string
	Desc string
}{
	{"adapter", "Assembly-based (like CLICK PLCs)"},
	{"logix_like", "Tag-based (like Allen-Bradley Logix)"},
}

const (
	serverFieldIP = iota
	serverFieldPort
	serverFieldPersonality
	serverFieldCount
)

// NewServerScreenModel creates a new server screen model.
func NewServerScreenModel(state *AppState) *ServerScreenModel {
	return &ServerScreenModel{
		state:    state,
		ListenIP: "0.0.0.0",
		Port:     "44818",
	}
}

// Update handles input for the server screen.
func (m *ServerScreenModel) Update(msg tea.KeyMsg) (*ServerScreenModel, tea.Cmd) {
	if m.Running {
		return m.updateRunning(msg)
	}
	if m.Completed {
		return m.updateCompleted(msg)
	}
	return m.updateEditing(msg)
}

func (m *ServerScreenModel) updateEditing(msg tea.KeyMsg) (*ServerScreenModel, tea.Cmd) {
	switch msg.String() {
	case "tab", "down", "j":
		m.focusIndex = (m.focusIndex + 1) % serverFieldCount
	case "shift+tab", "up", "k":
		m.focusIndex = (m.focusIndex - 1 + serverFieldCount) % serverFieldCount
	case "enter":
		return m.startServer()
	case "e":
		// Open config in editor
		configPath := m.ConfigPath
		if configPath == "" {
			configPath = filepath.Join(m.state.WorkspaceRoot, "profiles", "server_config.yaml")
		}
		// Check if file exists, create template if not
		if _, err := os.Stat(configPath); os.IsNotExist(err) {
			template := `# CIPDIP Server Configuration
# Generated by TUI

server:
  name: "CIPDIP Server Emulator"
  personality: "adapter"
  tcp_port: 44818
  udp_io_port: 2222

adapter_assemblies:
  - name: "InputAssembly1"
    class: 0x04
    instance: 0x65
    attribute: 0x03
    size_bytes: 16
    update_pattern: "counter"
`
			if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil {
				m.Status = fmt.Sprintf("Failed to create directory: %v", err)
				return m, nil
			}
			if err := os.WriteFile(configPath, []byte(template), 0644); err != nil {
				m.Status = fmt.Sprintf("Failed to create config: %v", err)
				return m, nil
			}
		}
		m.ConfigPath = configPath
		if err := OpenEditor(configPath); err != nil {
			m.Status = fmt.Sprintf("Editor failed: %v", err)
		} else {
			m.Status = fmt.Sprintf("Edited: %s", filepath.Base(configPath))
		}
	case "y":
		cmd := m.buildCommand()
		if err := copyToClipboard(cmd); err != nil {
			m.Status = fmt.Sprintf("Copy failed: %v", err)
		} else {
			m.Status = "Command copied to clipboard"
		}
	case "backspace":
		m.handleBackspace()
	default:
		if len(msg.String()) == 1 {
			m.handleCharInput(msg.String())
		}
	}

	// Handle personality selection with number keys, space, or arrows
	if m.focusIndex == serverFieldPersonality {
		switch msg.String() {
		case "1", "2":
			idx := int(msg.String()[0] - '1')
			if idx >= 0 && idx < len(serverPersonalities) {
				m.Personality = idx
			}
		case " ", "right", "l":
			m.Personality = (m.Personality + 1) % len(serverPersonalities)
		case "left", "h":
			m.Personality = (m.Personality - 1 + len(serverPersonalities)) % len(serverPersonalities)
		}
	}

	return m, nil
}

func (m *ServerScreenModel) updateRunning(msg tea.KeyMsg) (*ServerScreenModel, tea.Cmd) {
	switch msg.String() {
	case "x":
		if m.state.ServerCancel != nil {
			m.state.ServerCancel()
		}
		m.Running = false
		m.state.ServerRunning = false
		m.Status = "Server stopped"
	case "l":
		// Toggle full log view
	case "f":
		// Filter by IP
		m.Status = "IP filter not yet implemented"
	}
	return m, nil
}

func (m *ServerScreenModel) updateCompleted(msg tea.KeyMsg) (*ServerScreenModel, tea.Cmd) {
	switch msg.String() {
	case "enter", "esc":
		// Return to editing mode
		m.Completed = false
		m.Output = ""
		m.Status = ""
	case "r":
		// Re-run server
		m.Completed = false
		return m.startServer()
	case "o":
		// Open artifacts
		if m.RunDir != "" {
			if err := OpenEditor(m.RunDir + "/stdout.log"); err != nil {
				m.Status = fmt.Sprintf("Failed to open: %v", err)
			}
		}
	}
	return m, nil
}

func (m *ServerScreenModel) handleBackspace() {
	switch m.focusIndex {
	case serverFieldIP:
		if len(m.ListenIP) > 0 {
			m.ListenIP = m.ListenIP[:len(m.ListenIP)-1]
		}
	case serverFieldPort:
		if len(m.Port) > 0 {
			m.Port = m.Port[:len(m.Port)-1]
		}
	}
}

func (m *ServerScreenModel) handleCharInput(ch string) {
	switch m.focusIndex {
	case serverFieldIP:
		if strings.ContainsAny(ch, "0123456789.") {
			m.ListenIP += ch
		}
	case serverFieldPort:
		if strings.ContainsAny(ch, "0123456789") {
			m.Port += ch
		}
	}
}

func (m *ServerScreenModel) startServer() (*ServerScreenModel, tea.Cmd) {
	m.Running = true
	m.Status = "Starting server..."
	m.ConnectionCount = 0
	m.RequestCount = 0
	m.ErrorCount = 0
	m.Connections = nil
	m.RecentRequests = nil
	now := time.Now()
	m.StartTime = &now
	m.Uptime = 0

	// Set up cancellation context
	ctx, cancel := context.WithCancel(context.Background())
	m.state.ServerCtx = ctx
	m.state.ServerCancel = cancel
	m.state.ServerRunning = true

	// Build the command
	args := m.buildCommandArgs()
	command := CommandSpec{Args: args}

	// Create run directory for server
	runName := fmt.Sprintf("server_%s", serverPersonalities[m.Personality].Name)
	runDir, err := CreateRunDir(m.state.WorkspaceRoot, runName)
	if err != nil {
		m.Status = fmt.Sprintf("Failed to create run directory: %v", err)
		m.Running = false
		m.state.ServerRunning = false
		return m, nil
	}

	// Return a command that executes the server
	startTime := time.Now()
	return m, func() tea.Msg {
		stdout, exitCode, runErr := ExecuteCommand(ctx, command)

		// Write artifacts
		resolved := map[string]interface{}{
			"personality": serverPersonalities[m.Personality].Name,
			"listen_ip":   m.ListenIP,
			"port":        m.Port,
		}
		status := "success"
		if runErr != nil && ctx.Err() == nil {
			// Only mark as failed if not cancelled
			status = "failed"
		} else if ctx.Err() != nil {
			status = "stopped"
		}
		summary := RunSummary{
			Status:     status,
			Command:    args,
			StartedAt:  startTime.UTC().Format(time.RFC3339),
			FinishedAt: time.Now().UTC().Format(time.RFC3339),
			ExitCode:   exitCode,
		}
		_ = WriteRunArtifacts(runDir, resolved, args, stdout, summary)

		return serverStatusMsg{
			Stopped: true,
			Stdout:  stdout,
			RunDir:  runDir,
			Err:     runErr,
		}
	}
}

func (m *ServerScreenModel) buildCommandArgs() []string {
	args := []string{"cipdip", "server", "--personality", serverPersonalities[m.Personality].Name}
	if m.ListenIP != "" && m.ListenIP != "0.0.0.0" {
		args = append(args, "--listen-ip", m.ListenIP)
	}
	if m.Port != "" && m.Port != "44818" {
		args = append(args, "--listen-port", m.Port)
	}
	if m.ConfigPath != "" {
		args = append(args, "--server-config", m.ConfigPath)
	}
	return args
}

func (m *ServerScreenModel) buildCommand() string {
	return strings.Join(m.buildCommandArgs(), " ")
}

// View renders the server screen.
func (m *ServerScreenModel) View() string {
	if m.Running {
		return m.viewRunning()
	}
	if m.Completed {
		return m.viewCompleted()
	}
	return m.viewEditing()
}

func (m *ServerScreenModel) viewEditing() string {
	var b strings.Builder

	// Header
	b.WriteString(headerStyle.Render("SERVER"))
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Listen IP field
	ipLabel := "Listen IP: "
	ipValue := m.ListenIP
	if ipValue == "" {
		ipValue = "0.0.0.0"
	}
	if m.focusIndex == serverFieldIP {
		b.WriteString(selectedStyle.Render(ipLabel + ipValue + "█"))
	} else {
		b.WriteString(ipLabel + ipValue)
	}
	b.WriteString("            ")

	// Port field
	portLabel := "TCP Port: "
	portValue := m.Port
	if portValue == "" {
		portValue = "44818"
	}
	if m.focusIndex == serverFieldPort {
		b.WriteString(selectedStyle.Render(portLabel + portValue + "█"))
	} else {
		b.WriteString(portLabel + portValue)
	}
	b.WriteString("\n\n")

	// Personality selection
	b.WriteString("Personality:\n")
	for i, p := range serverPersonalities {
		prefix := "  ( ) "
		if i == m.Personality {
			prefix = "  (•) "
		}
		line := fmt.Sprintf("%s%-12s %s", prefix, p.Name, p.Desc)
		if m.focusIndex == serverFieldPersonality && i == m.Personality {
			b.WriteString(selectedStyle.Render(line))
		} else {
			b.WriteString(line)
		}
		b.WriteString("\n")
	}

	// Config info
	b.WriteString("\n")
	if m.ConfigPath != "" {
		b.WriteString(fmt.Sprintf("Config: %s                    [e]dit\n", m.ConfigPath))
	} else {
		b.WriteString(dimStyle.Render("Config: [none - using defaults]                    [e]dit"))
		b.WriteString("\n")
	}

	// Separator
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Command preview
	b.WriteString("Command preview:\n")
	b.WriteString(dimStyle.Render(m.buildCommand()))
	b.WriteString("\n")

	// Status
	if m.Status != "" {
		b.WriteString("\n")
		b.WriteString(m.Status)
	}

	return borderStyle.Render(b.String())
}

func (m *ServerScreenModel) viewRunning() string {
	var b strings.Builder

	// Header with running indicator
	b.WriteString(headerStyle.Render("SERVER"))
	b.WriteString("                                          ")
	b.WriteString(warningStyle.Render("[RUNNING]"))
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Server info
	b.WriteString(fmt.Sprintf("Listening: %s:%s      Personality: %s\n",
		m.ListenIP, m.Port, serverPersonalities[m.Personality].Name))
	b.WriteString(fmt.Sprintf("Uptime: %s              Connections: %d active\n",
		formatDuration(m.Uptime), m.ConnectionCount))

	// Progress bar
	b.WriteString("\n")
	b.WriteString("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	b.WriteString("\n\n")

	// Active connections
	b.WriteString("Active connections:\n")
	if len(m.Connections) == 0 {
		b.WriteString(dimStyle.Render("  (no active connections)"))
		b.WriteString("\n")
	} else {
		for _, conn := range m.Connections {
			b.WriteString(fmt.Sprintf("  %s  session=%s  idle %.1fs\n",
				conn.RemoteAddr, conn.SessionID, conn.IdleTime.Seconds()))
		}
	}

	// Recent requests
	b.WriteString("\n")
	b.WriteString("Recent requests:\n")
	if len(m.RecentRequests) == 0 {
		b.WriteString(dimStyle.Render("  (no requests yet)"))
		b.WriteString("\n")
	} else {
		displayReqs := m.RecentRequests
		if len(displayReqs) > 5 {
			displayReqs = displayReqs[len(displayReqs)-5:]
		}
		for _, req := range displayReqs {
			b.WriteString(fmt.Sprintf("  %s  %s  %s %s\n",
				req.Time.Format("15:04:05"), req.RemoteAddr, req.Service, req.Path))
		}
	}

	// Statistics
	b.WriteString("\n")
	b.WriteString("Statistics:\n")
	b.WriteString(fmt.Sprintf("  Total requests: %d    Errors: %d\n", m.RequestCount, m.ErrorCount))

	// Status
	if m.Status != "" {
		b.WriteString("\n")
		b.WriteString(m.Status)
	}

	return borderStyle.Render(b.String())
}

func (m *ServerScreenModel) viewCompleted() string {
	var b strings.Builder

	// Header with status indicator
	b.WriteString(headerStyle.Render("SERVER"))
	b.WriteString("                                          ")
	if strings.HasPrefix(m.Status, "FAILED") {
		b.WriteString(errorStyle.Render("[FAILED]"))
	} else {
		b.WriteString(successStyle.Render("[STOPPED]"))
	}
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Server info
	b.WriteString(fmt.Sprintf("Listen: %s:%s    Personality: %s\n",
		m.ListenIP, m.Port, serverPersonalities[m.Personality].Name))
	b.WriteString(fmt.Sprintf("Uptime: %s\n", formatDuration(m.Uptime)))

	// Status message
	b.WriteString("\n")
	if strings.HasPrefix(m.Status, "FAILED") {
		b.WriteString(errorStyle.Render(m.Status))
	} else {
		b.WriteString(successStyle.Render(m.Status))
	}
	b.WriteString("\n")

	// Output section
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n")
	b.WriteString("Output:\n")
	if m.Output == "" {
		b.WriteString(dimStyle.Render("  (no output captured)"))
		b.WriteString("\n")
	} else {
		// Show output lines (limit to last 15 lines)
		lines := strings.Split(strings.TrimSpace(m.Output), "\n")
		startIdx := 0
		if len(lines) > 15 {
			startIdx = len(lines) - 15
			b.WriteString(dimStyle.Render(fmt.Sprintf("  ... (%d lines omitted)\n", startIdx)))
		}
		for _, line := range lines[startIdx:] {
			if len(line) > 70 {
				line = line[:67] + "..."
			}
			b.WriteString(fmt.Sprintf("  %s\n", line))
		}
	}

	return borderStyle.Render(b.String())
}

// Footer returns the footer text for the server screen.
func (m *ServerScreenModel) Footer() string {
	if m.Running {
		return "x: stop    l: full log    f: filter by IP    m: menu"
	}
	if m.Completed {
		return "Enter/Esc: back to config    r: restart    o: open log    m: menu"
	}
	return "Tab: next    ←→: personality    Enter: start    e: edit    y: copy    m: menu"
}

func formatDuration(d time.Duration) string {
	h := int(d.Hours())
	m := int(d.Minutes()) % 60
	s := int(d.Seconds()) % 60
	return fmt.Sprintf("%02d:%02d:%02d", h, m, s)
}
