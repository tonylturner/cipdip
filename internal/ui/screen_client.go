package ui

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

// ClientScreenModel handles the client configuration screen.
type ClientScreenModel struct {
	state *AppState

	// Form fields
	TargetIP   string
	Port       string
	Scenario   int // Index into scenarios slice
	ConfigPath string

	// UI state
	focusIndex int // Which field is focused
	Running    bool
	Paused     bool
	Completed  bool   // True after a run finishes (success or failure)
	Status     string
	Output     string // Captured stdout from the run
	RunDir     string // Directory where artifacts were saved

	// Stats when running
	StartTime    *time.Time
	Elapsed      string
	RequestCount int
	SuccessCount int
	ErrorCount   int
	AvgLatency   string
	LastResponse string
	Errors       []string
}

var clientScenarios = []struct {
	Name string
	Desc string
}{
	{"baseline", "Read-only polling of configured targets"},
	{"mixed", "Alternating reads and writes"},
	{"stress", "High-frequency burst traffic"},
	{"io", "Connected I/O with Forward Open"},
	{"edge", "Protocol edge cases for DPI testing"},
}

const (
	clientFieldIP = iota
	clientFieldPort
	clientFieldScenario
	clientFieldCount
)

// NewClientScreenModel creates a new client screen model.
func NewClientScreenModel(state *AppState) *ClientScreenModel {
	return &ClientScreenModel{
		state: state,
		Port:  "44818",
	}
}

// Update handles input for the client screen.
func (m *ClientScreenModel) Update(msg tea.KeyMsg) (*ClientScreenModel, tea.Cmd) {
	if m.Running {
		return m.updateRunning(msg)
	}
	if m.Completed {
		return m.updateCompleted(msg)
	}
	return m.updateEditing(msg)
}

func (m *ClientScreenModel) updateEditing(msg tea.KeyMsg) (*ClientScreenModel, tea.Cmd) {
	switch msg.String() {
	case "tab", "down", "j":
		m.focusIndex = (m.focusIndex + 1) % clientFieldCount
	case "shift+tab", "up", "k":
		m.focusIndex = (m.focusIndex - 1 + clientFieldCount) % clientFieldCount
	case "enter":
		if m.TargetIP != "" {
			return m.startRun()
		}
	case "e":
		// Open config in editor
		configPath := m.ConfigPath
		if configPath == "" {
			// Create default config path
			configPath = filepath.Join(m.state.WorkspaceRoot, "profiles", "client_config.yaml")
		}
		// Check if file exists, create template if not
		if _, err := os.Stat(configPath); os.IsNotExist(err) {
			// Create a template config
			template := `# CIPDIP Client Configuration
# Generated by TUI

adapter:
  name: "Target Device"
  port: 44818

read_targets:
  - name: "Identity"
    service: "get_attribute_single"
    class: 0x01
    instance: 0x01
    attribute: 0x01
`
			if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil {
				m.Status = fmt.Sprintf("Failed to create directory: %v", err)
				return m, nil
			}
			if err := os.WriteFile(configPath, []byte(template), 0644); err != nil {
				m.Status = fmt.Sprintf("Failed to create config: %v", err)
				return m, nil
			}
		}
		m.ConfigPath = configPath
		if err := OpenEditor(configPath); err != nil {
			m.Status = fmt.Sprintf("Editor failed: %v", err)
		} else {
			m.Status = fmt.Sprintf("Edited: %s", filepath.Base(configPath))
		}
	case "y":
		// Copy command
		cmd := m.buildCommand()
		if err := copyToClipboard(cmd); err != nil {
			m.Status = fmt.Sprintf("Copy failed: %v", err)
		} else {
			m.Status = "Command copied to clipboard"
		}
	case "backspace":
		m.handleBackspace()
	default:
		// Handle character input for focused field
		if len(msg.String()) == 1 {
			m.handleCharInput(msg.String())
		}
	}

	// Handle scenario selection with number keys, space, or arrows
	if m.focusIndex == clientFieldScenario {
		switch msg.String() {
		case "1", "2", "3", "4", "5":
			idx := int(msg.String()[0] - '1')
			if idx >= 0 && idx < len(clientScenarios) {
				m.Scenario = idx
			}
		case " ", "right", "l":
			m.Scenario = (m.Scenario + 1) % len(clientScenarios)
		case "left", "h":
			m.Scenario = (m.Scenario - 1 + len(clientScenarios)) % len(clientScenarios)
		}
	}

	return m, nil
}

func (m *ClientScreenModel) updateRunning(msg tea.KeyMsg) (*ClientScreenModel, tea.Cmd) {
	switch msg.String() {
	case "x":
		// Stop run
		if m.state.ClientCancel != nil {
			m.state.ClientCancel()
		}
		m.Running = false
		m.Status = "Run cancelled"
	case " ":
		// Toggle pause
		m.Paused = !m.Paused
		if m.Paused {
			m.Status = "Paused"
		} else {
			m.Status = "Resumed"
		}
	case "l":
		// Toggle full log view
		// TODO: implement log view
	}
	return m, nil
}

func (m *ClientScreenModel) updateCompleted(msg tea.KeyMsg) (*ClientScreenModel, tea.Cmd) {
	switch msg.String() {
	case "enter", "esc":
		// Return to editing mode
		m.Completed = false
		m.Output = ""
		m.Status = ""
	case "r":
		// Re-run with same settings
		m.Completed = false
		return m.startRun()
	case "o":
		// Open artifacts directory
		if m.RunDir != "" {
			if err := OpenEditor(m.RunDir + "/stdout.log"); err != nil {
				m.Status = fmt.Sprintf("Failed to open: %v", err)
			}
		}
	}
	return m, nil
}

func (m *ClientScreenModel) handleBackspace() {
	switch m.focusIndex {
	case clientFieldIP:
		if len(m.TargetIP) > 0 {
			m.TargetIP = m.TargetIP[:len(m.TargetIP)-1]
		}
	case clientFieldPort:
		if len(m.Port) > 0 {
			m.Port = m.Port[:len(m.Port)-1]
		}
	}
}

func (m *ClientScreenModel) handleCharInput(ch string) {
	switch m.focusIndex {
	case clientFieldIP:
		// Allow IP characters
		if strings.ContainsAny(ch, "0123456789.") {
			m.TargetIP += ch
		}
	case clientFieldPort:
		// Allow port numbers
		if strings.ContainsAny(ch, "0123456789") {
			m.Port += ch
		}
	}
}

func (m *ClientScreenModel) startRun() (*ClientScreenModel, tea.Cmd) {
	if m.TargetIP == "" {
		m.Status = "Target IP is required"
		return m, nil
	}

	m.Running = true
	m.Status = "Starting..."
	m.RequestCount = 0
	m.SuccessCount = 0
	m.ErrorCount = 0
	m.Errors = nil
	now := time.Now()
	m.StartTime = &now
	m.Elapsed = "00:00:00"

	// Set up cancellation context
	ctx, cancel := context.WithCancel(context.Background())
	m.state.ClientCtx = ctx
	m.state.ClientCancel = cancel
	m.state.ClientRunning = true

	// Build the command
	args := m.buildCommandArgs()
	command := CommandSpec{Args: args}

	// Create run directory
	runName := fmt.Sprintf("client_%s", clientScenarios[m.Scenario].Name)
	runDir, err := CreateRunDir(m.state.WorkspaceRoot, runName)
	if err != nil {
		m.Status = fmt.Sprintf("Failed to create run directory: %v", err)
		m.Running = false
		m.state.ClientRunning = false
		return m, nil
	}

	// Return a command that executes the client
	startTime := time.Now()
	return m, func() tea.Msg {
		stdout, exitCode, runErr := ExecuteCommand(ctx, command)

		// Write artifacts
		resolved := map[string]interface{}{
			"scenario": clientScenarios[m.Scenario].Name,
			"target":   m.TargetIP,
			"port":     m.Port,
		}
		status := "success"
		if runErr != nil {
			status = "failed"
		}
		summary := RunSummary{
			Status:     status,
			Command:    args,
			StartedAt:  startTime.UTC().Format(time.RFC3339),
			FinishedAt: time.Now().UTC().Format(time.RFC3339),
			ExitCode:   exitCode,
		}
		_ = WriteRunArtifacts(runDir, resolved, args, stdout, summary)

		return runResultMsg{
			RunDir:   runDir,
			ExitCode: exitCode,
			Stdout:   stdout,
			Err:      runErr,
		}
	}
}

func (m *ClientScreenModel) buildCommandArgs() []string {
	args := []string{"cipdip", "client"}
	if m.TargetIP != "" {
		args = append(args, "--ip", m.TargetIP)
	}
	if m.Port != "" && m.Port != "44818" {
		args = append(args, "--port", m.Port)
	}
	args = append(args, "--scenario", clientScenarios[m.Scenario].Name)
	if m.ConfigPath != "" {
		args = append(args, "--config", m.ConfigPath)
	}
	return args
}

func (m *ClientScreenModel) buildCommand() string {
	return strings.Join(m.buildCommandArgs(), " ")
}

// View renders the client screen.
func (m *ClientScreenModel) View() string {
	if m.Running {
		return m.viewRunning()
	}
	if m.Completed {
		return m.viewCompleted()
	}
	return m.viewEditing()
}

func (m *ClientScreenModel) viewEditing() string {
	var b strings.Builder

	// Header
	header := "CLIENT"
	if m.ConfigPath != "" {
		header += "                                            [config]"
	}
	b.WriteString(headerStyle.Render(header))
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Target IP field
	ipLabel := "Target IP: "
	ipValue := m.TargetIP
	if ipValue == "" {
		ipValue = "_____________"
	}
	if m.focusIndex == clientFieldIP {
		b.WriteString(selectedStyle.Render(ipLabel + ipValue + "█"))
	} else {
		b.WriteString(ipLabel + ipValue)
	}
	b.WriteString("    ")

	// Port field
	portLabel := "Port: "
	portValue := m.Port
	if portValue == "" {
		portValue = "_____"
	}
	if m.focusIndex == clientFieldPort {
		b.WriteString(selectedStyle.Render(portLabel + portValue + "█"))
	} else {
		b.WriteString(portLabel + portValue)
	}
	b.WriteString("\n\n")

	// Scenario selection
	b.WriteString("Scenario:\n")
	for i, scenario := range clientScenarios {
		prefix := "  ( ) "
		if i == m.Scenario {
			prefix = "  (•) "
		}
		line := fmt.Sprintf("%s%-12s %s", prefix, scenario.Name, scenario.Desc)
		if m.focusIndex == clientFieldScenario && i == m.Scenario {
			b.WriteString(selectedStyle.Render(line))
		} else {
			b.WriteString(line)
		}
		b.WriteString("\n")
	}

	// Config info
	b.WriteString("\n")
	if m.ConfigPath != "" {
		b.WriteString(fmt.Sprintf("Config: %s                    [e]dit\n", m.ConfigPath))
	} else {
		b.WriteString(dimStyle.Render("Config: [none - using defaults]                    [e]dit"))
		b.WriteString("\n")
	}

	// Separator
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Command preview
	b.WriteString("Command preview:\n")
	cmd := m.buildCommand()
	if m.TargetIP == "" {
		cmd = strings.Replace(cmd, "--ip ", "--ip ???", 1)
	}
	b.WriteString(dimStyle.Render(cmd))
	b.WriteString("\n")

	// Status
	if m.Status != "" {
		b.WriteString("\n")
		b.WriteString(m.Status)
	}

	return borderStyle.Render(b.String())
}

func (m *ClientScreenModel) viewRunning() string {
	var b strings.Builder

	// Header with running indicator
	b.WriteString(headerStyle.Render("CLIENT"))
	b.WriteString("                                          ")
	b.WriteString(warningStyle.Render("[RUNNING]"))
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Target info
	b.WriteString(fmt.Sprintf("Target: %s:%s    Scenario: %s\n",
		m.TargetIP, m.Port, clientScenarios[m.Scenario].Name))
	b.WriteString(fmt.Sprintf("Elapsed: %s             Requests: %d\n",
		m.Elapsed, m.RequestCount))

	// Progress bar
	b.WriteString("\n")
	b.WriteString("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	b.WriteString("\n\n")

	// Statistics
	b.WriteString("Statistics:\n")
	successPct := float64(0)
	if m.RequestCount > 0 {
		successPct = float64(m.SuccessCount) / float64(m.RequestCount) * 100
	}
	b.WriteString(fmt.Sprintf("  Success:     %d  (%.2f%%)\n", m.SuccessCount, successPct))
	errorPct := float64(0)
	if m.RequestCount > 0 {
		errorPct = float64(m.ErrorCount) / float64(m.RequestCount) * 100
	}
	b.WriteString(fmt.Sprintf("  Errors:      %d  (%.2f%%)\n", m.ErrorCount, errorPct))
	b.WriteString(fmt.Sprintf("  Latency:     %s\n", m.AvgLatency))

	// Last response
	if m.LastResponse != "" {
		b.WriteString("\n")
		b.WriteString("Last response:\n")
		b.WriteString(fmt.Sprintf("  %s\n", m.LastResponse))
	}

	// Recent errors
	if len(m.Errors) > 0 {
		b.WriteString("\n")
		b.WriteString("Errors:\n")
		displayErrors := m.Errors
		if len(displayErrors) > 5 {
			displayErrors = displayErrors[len(displayErrors)-5:]
		}
		for _, err := range displayErrors {
			b.WriteString(errorStyle.Render(fmt.Sprintf("  %s\n", err)))
		}
	}

	// Status
	if m.Status != "" {
		b.WriteString("\n")
		b.WriteString(m.Status)
	}

	return borderStyle.Render(b.String())
}

func (m *ClientScreenModel) viewCompleted() string {
	var b strings.Builder

	// Header with status indicator
	b.WriteString(headerStyle.Render("CLIENT"))
	b.WriteString("                                          ")
	if strings.HasPrefix(m.Status, "FAILED") {
		b.WriteString(errorStyle.Render("[FAILED]"))
	} else {
		b.WriteString(successStyle.Render("[DONE]"))
	}
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n\n")

	// Target info
	b.WriteString(fmt.Sprintf("Target: %s:%s    Scenario: %s\n",
		m.TargetIP, m.Port, clientScenarios[m.Scenario].Name))
	b.WriteString(fmt.Sprintf("Elapsed: %s\n", m.Elapsed))

	// Status message
	b.WriteString("\n")
	if strings.HasPrefix(m.Status, "FAILED") {
		b.WriteString(errorStyle.Render(m.Status))
	} else {
		b.WriteString(successStyle.Render(m.Status))
	}
	b.WriteString("\n")

	// Output section
	b.WriteString("\n")
	b.WriteString(strings.Repeat("─", 60))
	b.WriteString("\n")
	b.WriteString("Output:\n")
	if m.Output == "" {
		b.WriteString(dimStyle.Render("  (no output captured)"))
		b.WriteString("\n")
	} else {
		// Show output lines (limit to last 15 lines to fit in view)
		lines := strings.Split(strings.TrimSpace(m.Output), "\n")
		startIdx := 0
		if len(lines) > 15 {
			startIdx = len(lines) - 15
			b.WriteString(dimStyle.Render(fmt.Sprintf("  ... (%d lines omitted)\n", startIdx)))
		}
		for _, line := range lines[startIdx:] {
			if len(line) > 70 {
				line = line[:67] + "..."
			}
			b.WriteString(fmt.Sprintf("  %s\n", line))
		}
	}

	return borderStyle.Render(b.String())
}

// Footer returns the footer text for the client screen.
func (m *ClientScreenModel) Footer() string {
	if m.Running {
		return "x: stop    Space: pause/resume    l: show full log    m: menu"
	}
	if m.Completed {
		return "Enter/Esc: back to config    r: re-run    o: open artifacts    m: menu"
	}
	return "Tab: next    ←→: scenario    Enter: run    e: edit    y: copy    m: menu"
}
