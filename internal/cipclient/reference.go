package cipclient

import (
	"fmt"
)

// Reference packets from known ODVA-compliant devices
// These can be used for validation and comparison

// ReferencePacket represents a reference packet for validation
type ReferencePacket struct {
	Name        string
	Description string
	Data        []byte
	Source      string // e.g., "Wireshark capture", "ODVA spec example", "Real device"
}

// ReferencePackets is a library of known-good ODVA-compliant packets
// Populated from:
// - CIPDIP baseline captures (baseline_captures/*.pcap)
// - Real-world device captures (pcaps/*.pcap)
// - Wireshark captures of compliant devices
//
// Reference packets are automatically populated from reference_packets_gen.go
// which is generated by running:
//   cipdip extract-reference --output internal/cipclient/reference_packets_gen.go
//
// The generated file contains init() functions that populate this map.
var ReferencePackets = map[string]ReferencePacket{
	// Placeholder structure - to be populated with actual reference packets
	"RegisterSession_Request": {
		Name:        "RegisterSession_Request",
		Description: "Standard RegisterSession request",
		Data:        nil, // TODO: Add actual reference packet
		Source:      "ODVA Specification",
	},
	"RegisterSession_Response": {
		Name:        "RegisterSession_Response",
		Description: "Standard RegisterSession response",
		Data:        nil, // TODO: Add actual reference packet
		Source:      "ODVA Specification",
	},
	"GetAttributeSingle_Request": {
		Name:        "GetAttributeSingle_Request",
		Description: "Get_Attribute_Single request for class 0x04, instance 0x65, attribute 0x03",
		Data:        nil, // TODO: Add actual reference packet
		Source:      "Wireshark Capture",
	},
	"GetAttributeSingle_Response": {
		Name:        "GetAttributeSingle_Response",
		Description: "Get_Attribute_Single response with 4-byte DINT value",
		Data:        nil, // TODO: Add actual reference packet
		Source:      "Wireshark Capture",
	},
	"ForwardOpen_Request": {
		Name:        "ForwardOpen_Request",
		Description: "Forward_Open request for I/O connection",
		Data:        nil, // TODO: Add actual reference packet
		Source:      "ODVA Specification",
	},
	"ForwardOpen_Response": {
		Name:        "ForwardOpen_Response",
		Description: "Forward_Open response with connection IDs",
		Data:        nil, // TODO: Add actual reference packet
		Source:      "ODVA Specification",
	},
}

// ResetReferencePackets clears populated reference data so extractions don't retain stale packets.
func ResetReferencePackets() {
	for key, ref := range ReferencePackets {
		ref.Data = nil
		ReferencePackets[key] = ref
	}
}

// CompareWithReference compares a generated packet with a reference packet
func CompareWithReference(name string, generated []byte) (bool, error) {
	ref, ok := ReferencePackets[name]
	if !ok {
		return false, fmt.Errorf("no reference packet for %s", name)
	}

	if len(ref.Data) == 0 {
		return false, fmt.Errorf("reference packet %s has no data (not yet populated)", name)
	}

	// Compare byte-by-byte; mismatch is a non-error result.
	if len(generated) != len(ref.Data) {
		return false, nil
	}

	for i := 0; i < len(generated); i++ {
		if generated[i] != ref.Data[i] {
			return false, nil
		}
	}

	return true, nil
}

// FindFirstDifference finds the first byte difference between two packets
func FindFirstDifference(packet1, packet2 []byte) (int, byte, byte) {
	minLen := len(packet1)
	if len(packet2) < minLen {
		minLen = len(packet2)
	}

	for i := 0; i < minLen; i++ {
		if packet1[i] != packet2[i] {
			return i, packet1[i], packet2[i]
		}
	}

	// If we get here, one packet is longer than the other
	if len(packet1) != len(packet2) {
		return minLen, 0, 0
	}

	return -1, 0, 0 // Packets are identical
}

// ValidatePacketStructure validates that a packet matches expected structure
// This is a structural validation, not byte-by-byte comparison
func ValidatePacketStructure(packet []byte, expectedStructure string) error {
	// Parse packet
	encap, err := DecodeENIP(packet)
	if err != nil {
		return fmt.Errorf("failed to decode packet: %w", err)
	}

	// Validate based on expected structure
	switch expectedStructure {
	case "RegisterSession_Request":
		if encap.Command != ENIPCommandRegisterSession {
			return fmt.Errorf("expected RegisterSession command, got 0x%04X", encap.Command)
		}
		if len(encap.Data) != 4 {
			return fmt.Errorf("expected 4 bytes of data, got %d", len(encap.Data))
		}
		// Additional validation can be added here
	case "RegisterSession_Response":
		if encap.Command != ENIPCommandRegisterSession {
			return fmt.Errorf("expected RegisterSession command, got 0x%04X", encap.Command)
		}
		if len(encap.Data) != 4 {
			return fmt.Errorf("expected 4 bytes of data, got %d", len(encap.Data))
		}

	case "GetAttributeSingle_Request":
		if encap.Command != ENIPCommandSendRRData {
			return fmt.Errorf("expected SendRRData command, got 0x%04X", encap.Command)
		}
		// Parse CIP data and validate
		if len(encap.Data) < 6 {
			return fmt.Errorf("SendRRData too short")
		}
		cipData := encap.Data[6:]
		if len(cipData) < 1 {
			return fmt.Errorf("CIP data too short")
		}
		if CIPServiceCode(cipData[0]) != CIPServiceGetAttributeSingle {
			return fmt.Errorf("expected Get_Attribute_Single service, got 0x%02X", cipData[0])
		}

	default:
		return fmt.Errorf("unknown expected structure: %s", expectedStructure)
	}

	return nil
}
