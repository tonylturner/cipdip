package reference

import (
	"fmt"

	"github.com/tturner/cipdip/internal/cip/protocol"
	"github.com/tturner/cipdip/internal/cip/spec"
	"github.com/tturner/cipdip/internal/enip"
)

// ReferencePacket represents a reference packet for validation.
type ReferencePacket struct {
	Name        string
	Description string
	Data        []byte
	Source      string // e.g., "Wireshark capture", "ODVA spec example", "Real device"
}

// EXPERIMENTAL: Reference packet comparison is currently incomplete.
// The reference packet library provides a framework for byte-level validation
// against known-good ODVA-compliant packets, but packet data has not yet been
// populated from real device captures.
//
// ReferencePackets is a library of known-good ODVA-compliant packets.
// Populated from:
// - CIPDIP baseline captures (baseline_captures/*.pcap)
// - Real-world device captures (pcaps/*.pcap)
// - Wireshark captures of compliant devices
//
// Reference packets are automatically populated from reference_packets_gen.go
// which is generated by running:
//
//	cipdip extract-reference --output internal/reference/reference_packets_gen.go
//
// The generated file contains init() functions that populate this map.
var ReferencePackets = map[string]ReferencePacket{
	// Reference packet stubs - data to be populated from real device captures.
	// Use ValidatePacketStructure() for structural validation, or
	// CompareWithReference() for byte-level comparison once data is populated.
	"RegisterSession_Request": {
		Name:        "RegisterSession_Request",
		Description: "Standard RegisterSession request",
		Data:        nil, // Pending: Extract from baseline captures
		Source:      "ODVA Specification",
	},
	"RegisterSession_Response": {
		Name:        "RegisterSession_Response",
		Description: "Standard RegisterSession response",
		Data:        nil, // Pending: Extract from baseline captures
		Source:      "ODVA Specification",
	},
	"GetAttributeSingle_Request": {
		Name:        "GetAttributeSingle_Request",
		Description: "Get_Attribute_Single request for class 0x04, instance 0x65, attribute 0x03",
		Data:        nil, // Pending: Extract from baseline captures
		Source:      "Wireshark Capture",
	},
	"GetAttributeSingle_Response": {
		Name:        "GetAttributeSingle_Response",
		Description: "Get_Attribute_Single response with 4-byte DINT value",
		Data:        nil, // Pending: Extract from baseline captures
		Source:      "Wireshark Capture",
	},
	"ForwardOpen_Request": {
		Name:        "ForwardOpen_Request",
		Description: "Forward_Open request for I/O connection",
		Data:        nil, // Pending: Extract from baseline captures
		Source:      "ODVA Specification",
	},
	"ForwardOpen_Response": {
		Name:        "ForwardOpen_Response",
		Description: "Forward_Open response with connection IDs",
		Data:        nil, // Pending: Extract from baseline captures
		Source:      "ODVA Specification",
	},
}

// ResetReferencePackets clears populated reference data so extractions don't retain stale packets.
func ResetReferencePackets() {
	for key, ref := range ReferencePackets {
		ref.Data = nil
		ReferencePackets[key] = ref
	}
}

// CompareWithReference compares a generated packet with a reference packet.
// Note: This function returns an error if the reference packet has not been populated.
// Use ValidatePacketStructure() for structural validation without byte-level comparison.
func CompareWithReference(name string, generated []byte) (bool, error) {
	ref, ok := ReferencePackets[name]
	if !ok {
		return false, fmt.Errorf("no reference packet for %s", name)
	}

	if len(ref.Data) == 0 {
		return false, fmt.Errorf("reference packet %s not yet populated (use ValidatePacketStructure for structural validation)", name)
	}

	// Compare byte-by-byte; mismatch is a non-error result.
	if len(generated) != len(ref.Data) {
		return false, nil
	}

	for i := 0; i < len(generated); i++ {
		if generated[i] != ref.Data[i] {
			return false, nil
		}
	}

	return true, nil
}

// FindFirstDifference finds the first byte difference between two packets.
func FindFirstDifference(packet1, packet2 []byte) (int, byte, byte) {
	minLen := len(packet1)
	if len(packet2) < minLen {
		minLen = len(packet2)
	}

	for i := 0; i < minLen; i++ {
		if packet1[i] != packet2[i] {
			return i, packet1[i], packet2[i]
		}
	}

	// If we get here, one packet is longer than the other.
	if len(packet1) != len(packet2) {
		return minLen, 0, 0
	}

	return -1, 0, 0 // Packets are identical.
}

// ValidatePacketStructure validates that a packet matches expected structure.
// This is a structural validation, not byte-by-byte comparison.
func ValidatePacketStructure(packet []byte, expectedStructure string) error {
	// Parse packet.
	encap, err := enip.DecodeENIP(packet)
	if err != nil {
		return fmt.Errorf("failed to decode packet: %w", err)
	}

	// Validate based on expected structure.
	switch expectedStructure {
	case "RegisterSession_Request":
		if encap.Command != enip.ENIPCommandRegisterSession {
			return fmt.Errorf("expected RegisterSession command, got 0x%04X", encap.Command)
		}
		if len(encap.Data) != 4 {
			return fmt.Errorf("expected 4 bytes of data, got %d", len(encap.Data))
		}
		// Additional validation can be added here.
	case "RegisterSession_Response":
		if encap.Command != enip.ENIPCommandRegisterSession {
			return fmt.Errorf("expected RegisterSession command, got 0x%04X", encap.Command)
		}
		if len(encap.Data) != 4 {
			return fmt.Errorf("expected 4 bytes of data, got %d", len(encap.Data))
		}

	case "GetAttributeSingle_Request":
		if encap.Command != enip.ENIPCommandSendRRData {
			return fmt.Errorf("expected SendRRData command, got 0x%04X", encap.Command)
		}
		// Parse CIP data and validate.
		if len(encap.Data) < 6 {
			return fmt.Errorf("SendRRData too short")
		}
		cipData := encap.Data[6:]
		if len(cipData) < 1 {
			return fmt.Errorf("CIP data too short")
		}
		if protocol.CIPServiceCode(cipData[0]) != spec.CIPServiceGetAttributeSingle {
			return fmt.Errorf("expected Get_Attribute_Single service, got 0x%02X", cipData[0])
		}

	default:
		return fmt.Errorf("unknown expected structure: %s", expectedStructure)
	}

	return nil
}
