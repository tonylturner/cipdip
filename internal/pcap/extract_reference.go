package pcap

import (
	"encoding/binary"
	"fmt"
	"io"

	"github.com/tturner/cipdip/internal/cip/protocol"
	"github.com/tturner/cipdip/internal/cip/spec"
	"github.com/tturner/cipdip/internal/reference"
)

// FindReferencePackets finds key reference packets from a PCAP file.
func FindReferencePackets(pcapFile string) (map[string]ENIPPacket, error) {
	packets, err := ExtractENIPFromPCAP(pcapFile)
	if err != nil {
		return nil, err
	}

	referencePackets := make(map[string]ENIPPacket)

	// Look for key packet types.
	for _, pkt := range packets {
		key := getReferenceKey(pkt)
		if key != "" {
			// Only keep the first occurrence of each type.
			if _, exists := referencePackets[key]; !exists {
				referencePackets[key] = pkt
			}
		}
	}

	return referencePackets, nil
}

// getReferenceKey returns a key for the reference packet map.
func getReferenceKey(pkt ENIPPacket) string {
	if !isLittleEndianENIP(pkt.FullPacket) {
		return ""
	}
	switch pkt.Command {
	case 0x0065: // RegisterSession
		if pkt.IsRequest {
			return "RegisterSession_Request"
		}
		return "RegisterSession_Response"
	case 0x006F: // SendRRData
		if len(pkt.Data) >= 6 {
			cipData, _, _ := extractCIPFromENIP(pkt)
			if len(cipData) > 0 {
				serviceCode := cipData[0] &^ 0x80
				isResponse := cipData[0]&0x80 != 0
				switch protocol.CIPServiceCode(serviceCode) {
				case spec.CIPServiceGetAttributeSingle:
					if isResponse {
						return "GetAttributeSingle_Response"
					}
					return "GetAttributeSingle_Request"
				case spec.CIPServiceSetAttributeSingle:
					if isResponse {
						return "SetAttributeSingle_Response"
					}
					return "SetAttributeSingle_Request"
				case spec.CIPServiceForwardOpen:
					if isResponse {
						return "ForwardOpen_Response"
					}
					return "ForwardOpen_Request"
				case spec.CIPServiceForwardClose:
					if isResponse {
						return "ForwardClose_Response"
					}
					return "ForwardClose_Request"
				}
			}
		}
		return ""
	case 0x0070: // SendUnitData
		if pkt.IsRequest {
			return "SendUnitData_Request"
		}
		return "SendUnitData_Response"
	case 0x0063: // ListIdentity
		return "ListIdentity_Request"
	default:
		return ""
	}
}

func isLittleEndianENIP(packet []byte) bool {
	if len(packet) < 24 {
		return false
	}
	command := binary.LittleEndian.Uint16(packet[0:2])
	if !isValidENIPCommand(command) {
		return false
	}
	length := binary.LittleEndian.Uint16(packet[2:4])
	return len(packet) >= 24+int(length)
}

// PopulateReferenceLibraryFromPCAP populates the reference library from a PCAP file.
func PopulateReferenceLibraryFromPCAP(pcapFile string, source string) error {
	refPackets, err := FindReferencePackets(pcapFile)
	if err != nil {
		return fmt.Errorf("find reference packets: %w", err)
	}

	// Update ReferencePackets map.
	for key, pkt := range refPackets {
		// Normalize packet (remove session-specific fields for comparison).
		normalized := normalizePacket(pkt.FullPacket)

		reference.ReferencePackets[key] = reference.ReferencePacket{
			Name:        key,
			Description: pkt.Description,
			Data:        normalized,
			Source:      source,
		}
	}

	return nil
}

// normalizePacket normalizes a packet by zeroing out session-specific fields.
// This allows comparison across different sessions.
func normalizePacket(packet []byte) []byte {
	if len(packet) < 24 {
		return packet
	}

	normalized := make([]byte, len(packet))
	copy(normalized, packet)

	// Zero out session ID (bytes 4-7).
	for i := 4; i < 8; i++ {
		normalized[i] = 0
	}

	// Zero out sender context (bytes 12-19) - keep structure but normalize.
	// Actually, keep sender context as-is for now, as it's part of the protocol.

	return normalized
}

// WriteReferencePacketsToFile writes reference packets to a Go source file.
func WriteReferencePacketsToFile(w io.Writer) error {
	fmt.Fprintf(w, "// Code generated by pcap extraction tool. DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package reference\n\n")
	fmt.Fprintf(w, "func init() {\n")
	fmt.Fprintf(w, "\t// Populate reference packets from PCAP files\n")

	for key, ref := range reference.ReferencePackets {
		if len(ref.Data) == 0 {
			continue
		}
		fmt.Fprintf(w, "\tReferencePackets[%q] = ReferencePacket{\n", key)
		fmt.Fprintf(w, "\t\tName:        %q,\n", ref.Name)
		fmt.Fprintf(w, "\t\tDescription: %q,\n", ref.Description)
		fmt.Fprintf(w, "\t\tSource:      %q,\n", ref.Source)
		fmt.Fprintf(w, "\t\tData:        []byte{\n")

		// Write bytes in chunks of 16.
		for i := 0; i < len(ref.Data); i += 16 {
			fmt.Fprintf(w, "\t\t\t")
			for j := 0; j < 16 && i+j < len(ref.Data); j++ {
				if j > 0 {
					fmt.Fprintf(w, ", ")
				}
				fmt.Fprintf(w, "0x%02X", ref.Data[i+j])
			}
			fmt.Fprintf(w, ",\n")
		}
		fmt.Fprintf(w, "\t\t},\n")
		fmt.Fprintf(w, "\t}\n\n")
	}

	fmt.Fprintf(w, "}\n")
	return nil
}
